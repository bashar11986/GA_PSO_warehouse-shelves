# -*- coding: utf-8 -*-
"""GA_PSO_warehouse shelves.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Wg74bN4nUN8W9TH66unQgTP0jeOnKo_
"""



"""This program solves the problem of distributing objects on warehouse shelves using the genetic algorithm GA and using the swarm algorithm PSO. In the first case, we represent the shelves with a 5-square grid and in the second case, we represent them with an 8-square grid. ðŸ™‚"""

import random
gridSize1 = 5
gridSize2 = 8
robot_position = (1,1)
ex1 =[(2,1),(2,2),(2,3),(4,4),(4,5),(4,6)]
ex2 = [(3,2),(3,3),(3,4),(3,5),(6,5),(6,6),(6,7),(6,8),(7,7),(7,8),(7,9),(7,10)]
shelfPositionEx1 = [(2,1),(4,4)]
shelfPositionEx2 = [(3,2),(6,5),(7,7)]
itemsInShelfEx1=3
ItemsInShelfEx2=4
mutProb = 0.3  # mutation probability
elit = 0.1
maxIter = 100
c1=1
c2=1

########### genetic algorithm #############
def initial_gen_population(gridSize):   # initial random population of gens
    gensPop = []
    for i in range(gridSize):
        gen = []
        for j in range(gridSize):
            gen.append((random.randint(1,gridSize),random.randint(1,gridSize)))
        gensPop.append(gen)
    return gensPop
###_________________________________###
def gen_fitness(robot_position,gen):  #calculate distance between robot and all items
    fitness = 0
    for i in range (len(gen)):
        fitness += ((robot_position[0]-gen[i][0])**2 + (robot_position[1]-gen[i][1])**2)**0.5
    return fitness

###_________________________________###
def gen_mutation(gen):
    size = len(gen)
    randomIndex = random.randint(0,size-1)
    newGenWithMutation = []
    v = (random.randint(1,size), random.randint(1,size))
    mutatinInGen = []
    mutatinInGen.append(v)
    newGenWithMutation = gen[0:randomIndex] + mutatinInGen + gen[(randomIndex+1):]
    return newGenWithMutation
###_________________________________###

def gen_cross(gen1,gen2):
    randomIndex=random.randint(1,len(gen1)-2)
    crossGen = gen1[0:randomIndex] + gen2[randomIndex:]
    return crossGen
###_________________________________###
def gen_excut(population,elite,iteration,robotP,mutProb):
    opt_solution = []
    best_fitness = 0.0
    size = len(population)
    top_elite = int(elite*size)
    for i in range(iteration):
        individual_scores= [(gen_fitness(robotP,g),g)for g in population]
        individual_scores.sort()
        rank_individuals= [v for (s,v) in individual_scores]
        population = rank_individuals[0:top_elite]
        while len(population) < size:
            if random.random()<mutProb:
                #mutation
                c = random.randint(0,top_elite)
                population.append(gen_mutation(rank_individuals[c]))
            else:
                #crossover
                c1=random.randint(0,top_elite)
                c2=random.randint(0,top_elite)
                population.append(gen_cross(rank_individuals[c1],rank_individuals[c2]))
        opt_solution = individual_scores[0][1]
        best_fitness = individual_scores[0][0]
        fitnessString = "__fitness = " + str(best_fitness)
        if individual_scores[0][0]==0:
             return opt_solution , fitnessString
    return opt_solution , fitnessString
###_________________________________###
########### PSO algorithm #############
#######################################
def initial_pso_population(gridSize):   # initial random population of particls
    particlsPop = []
    particlsVelocities = []
    for i in range(gridSize):
        particl = []
        velocity = []
        for j in range(gridSize):
            particl.append((random.randint(1,gridSize),random.randint(1,gridSize)))
            velocity.append(random.uniform(2,4))
        particlsPop.append(particl)
        particlsVelocities.append(velocity)
    return particlsPop , particlsVelocities
###_________________________________###
def pso_pbest (robotP,particl):
    fitness = []
    for i in range (len(particl)):
        fitness.append(((robotP[0]-particl[i][0])**2 + (robotP[1]-particl[i][1])**2)**0.5)
    return fitness
###_________________________________###
def pso_gbest (robotP,population):
    minFitness = []
    for i in range (len(population[0])):
         minFitness.append(min( pso_pbest(robotP,population[0][i])))
    return minFitness
###_________________________________###
def pso_velocity_new(particl,population,oldVelocity,robotP,c1,c2):
        r1 = random.uniform(0,1)
        r2 = random.uniform(0,1)
        pbest = pso_pbest(robotP,particl)
        gbest = pso_gbest(robotP,population)
        pbestList=[]
        gbestList = []
        for i in range(len(particl)):
            pbestList.append(c1*r1*(pso_pbest(robotP,particl)[i]-particl[i][1]))
        for i in range(len(particl)):
            gbestList.append(c2*r2*(pso_gbest(robotP,population)[i]-particl[i][1]))
        newVelocity=[]
        for i in range(len(oldVelocity)):
            newVelocity.append(oldVelocity[i]+pbestList[i] +gbestList[i])
        return newVelocity
###_________________________________###
def pso_particl_new(population, position,oldVelocity):
        newParticl = []
        p = population[0][position]
        for i in range(len(p)):
            newParticl.append((population[0][position][i][0],abs(int(population[0][position][i][1] + oldVelocity[i]))))
        return newParticl
###_________________________________###
def pso_update_population(population, position,newParticl,newVelocity):
        newPop = population
        newPop[0][position] = newParticl
        newPop[1][position] = newVelocity
        return newPop
###_________________________________###
def pso_excut(population,iteration,robotP,c1,c2):
    size = len(population)
    updatedPop = population
    i = 0
    while i < iteration:
        for k in range(size):
            newVelocity = pso_velocity_new(updatedPop[0][k],updatedPop,updatedPop[1][k],robotP,c1,c2)
            newParticle = pso_particl_new(updatedPop,k,updatedPop[1][k])
            if(pso_pbest(robotP,updatedPop[0][k]) < pso_pbest(robotP,newParticle)):
                updatedPop = pso_update_population(updatedPop,k,newParticle,newVelocity)
        i+=1
    listOfFitness = pso_gbest(robotP,updatedPop)
    bestFitness = listOfFitness[0]
    bestFitnessIndex = 0
    finalFitness = 0;
    for j in range(len(listOfFitness)):
        finalFitness += listOfFitness[j]
        if listOfFitness[j] < bestFitness:
            bestFitness = listOfFitness[j]
            bestFitnessIndex = j
    optimalSolution = updatedPop[0][bestFitnessIndex]
    fitnessString = "__fitness = " + str(finalFitness)
    return optimalSolution , fitnessString
###_________________________________###

###__________ Excute algorithms: _______________###
pop1 = initial_gen_population(gridSize1)
pop2 = initial_gen_population(gridSize2)
print("=========================")
print("====  GA  ===============")
print("=========================")
print("iteration: " + str(maxIter))
print("GA algorithm __ example1")
print(gen_excut(pop1,elit,maxIter,robot_position,mutProb))
print("GA algorithm __ example2")
print(gen_excut(pop2,elit,maxIter,robot_position,mutProb))
print("=========================")
print("=====    PSO   ==========")
print("=========================")
pop3 = initial_pso_population(gridSize1)
pop4 = initial_pso_population(gridSize2)
print("iteration: " + str(maxIter))
print("PSO algorithm __ example1")
print(pso_excut(pop3,maxIter,robot_position,c1,c2))
print("PSO algorithm __ example2")
print(pso_excut(pop4,maxIter,robot_position,c1,c2))
print("=========================")